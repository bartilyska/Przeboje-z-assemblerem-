.686
.model flat
extern _ExitProcess@4 : PROC
extern __write : PROC ; (dwa znaki podkreœlenia)
extern __read : PROC ; (dwa znaki podkreœlenia)
extern _MessageBoxA@16 : PROC
public _main
.data
    tekst_pocz db 10, 'Proszê napisaæ jakiœ tekst '
    db 'i nacisnac Enter', 10
    koniec_t db ?
    magazyn db 80 dup (?)
    nowa_linia db 10
    liczba_znakow dd ?
    ;             ¹    æ    ê    ³    ñ    ó  œ  Ÿ   ¿
    malelatin db 165, 134, 169, 136,228,162,152,171,190
    duzelatin db 164, 143, 168, 157, 227,224,151,141,189
    male1250 db 185,230,234,179,241,243,156,159,191 ;1250 jest dla MessageBoxA
    duze1250 db 165,198,202,163,209,211,140,143,175
.code
_main PROC
    ; wyœwietlenie tekstu informacyjnego
    ; liczba znaków tekstu
    mov ecx,(OFFSET koniec_t) - (OFFSET tekst_pocz) ; fajny sposób na liczenie iloœci znaków
    push ecx
    push OFFSET tekst_pocz ; adres tekstu
    push 1 ; nr urz¹dzenia (tu: ekran - nr 1)
    call __write ; wyœwietlenie tekstu pocz¹tkowego
    add esp, 12 ; usuniêcie parametrów ze stosu
    ; czytanie wiersza z klawiatury
    push 80 ; maksymalna liczba znaków
    push OFFSET magazyn
    push 0 ; nr urz¹dzenia (tu: klawiatura - nr 0)
    call __read ; czytanie znaków z klawiatury
    add esp, 12 ; usuniêcie parametrów ze stosu
    ; kody ASCII napisanego tekstu zosta³y wprowadzone
    ; do obszaru 'magazyn'
    ; funkcja read wpisuje do rejestru EAX liczbê
    ; wprowadzonych znaków
    dec eax ;zeby nie ogarnialo ostatniego entera
    mov liczba_znakow, eax
    ; rejestr ECX pe³ni rolê licznika obiegów pêtli
    mov ecx, eax
    mov ebx, 0 ; indeks pocz¹tkowy
ptl:
    mov dl, magazyn[ebx] ; pobranie kolejnego znaku
    ; Sprawdzamy, czy znak jest ma³¹ liter¹ ASCII
    cmp dl, 'A'
    jb zamien_na_gwiazdke ; skok, gdy znak nie wymaga zamiany
    cmp dl, 'Z'
    ja szukaj_malych_liter ; skok, gdy znak nie wymaga zamiany
    add dl, 20H ; zamiana na male litery
    ; odes³anie znaku do pamiêci
    mov magazyn[ebx], dl
    jmp dalej

szukaj_malych_liter:
    cmp dl,'a' ;tu jestem tylko gdy to nie sa litery A-Z 
    jb zamien_na_gwiazdke
    cmp dl, 'z'
    ja sprawdz_ogonki
    sub dl, 20H ; male zamienione na duze
    mov magazyn[ebx], dl
    jmp dalej

zamien_na_gwiazdke:
    mov dl,42
    mov magazyn[ebx], dl
    jmp dalej

sprawdz_ogonki: 
    ; Sprawdzanie znaków z ogonkami
    mov esi, 0
petla_ogonki:
    cmp dl, malelatin[esi] ; porównujemy z liter¹ z tablicy ma³ych liter z ogonkami
    je zamien_male_ogonki ; jeœli znak pasuje, przechodzimy do zamiany
    cmp dl, duzelatin[esi] ; jezeli jest duza z ogonkiem to trzeba zmienic na odpowiednik
    je zamien_duze_ogonki ; jezeli to duza z ogonkiem to na mala
    inc esi
    cmp esi, 9 ; mamy 9 znaków z ogonkami
    jne petla_ogonki
    jmp zamien_na_gwiazdke ; jeœli nie znaleziono pasuj¹cego znaku, zamieniamy na gwiazdke wszystko powyzej 'z'

zamien_male_ogonki:
    mov dl, duze1250[esi] ; zamiana na wielk¹ literê z ogonkiem
    mov magazyn[ebx], dl
    jmp dalej ; wazny jump zeby nie wraca³o bo juz zmienilo

zamien_duze_ogonki:
    mov dl, male1250[esi]
    mov magazyn[ebx], dl
    jmp dalej

dalej:
    inc ebx ; inkrementacja indeksu
    dec ecx
    jnz ptl
    ; wyœwietlenie przekszta³conego tekstu
    ;push liczba_znakow
    ;push OFFSET magazyn
    ;push 1
    ;call __write ; wyœwietlenie przekszta³conego tekstu
    ;boxA
    push 0 ; sta³a MB_OK
        ; adres obszaru zawieraj¹cego tytu³
    push OFFSET magazyn
        ; adres obszaru zawieraj¹cego tekst
    push OFFSET magazyn
    push 0 ; NULL
    call _MessageBoxA@16
    add esp, 16 ; usuniêcie parametrów ze stosu
    push 0
    call _ExitProcess@4 ; zakoñczenie programu
_main ENDP
END
